---
title: 'create_repository_note'
description: 'Store important development insights and decisions for future reference'
---

# create_repository_note

Create and store tribal knowledge, best practices, and important decisions in the repository's knowledge base.

## Overview

The `create_repository_note` tool allows you to capture and preserve institutional knowledge that AI agents and team members can access later. This is essential for maintaining project continuity and sharing knowledge across the team.

<RequestExample>
```json
{
  "note": "We decided to use React Query for server state management instead of Redux because it provides better caching, background refetching, and error handling out of the box.",
  "directoryPath": "/src/hooks",
  "tags": ["architecture", "state-management", "performance"],
  "anchors": ["/src/hooks/useUser.ts", "/src/hooks/useProducts.ts"],
  "confidence": "high",
  "type": "decision",
  "metadata": {
    "alternatives_considered": ["Redux Toolkit", "Zustand", "SWR"],
    "rationale": "Better developer experience and automatic caching",
    "migration_plan": "Gradual migration from existing Redux setup"
  }
}
```
</RequestExample>

## Parameters

| Parameter       | Type     | Required | Description                                                            |
| --------------- | -------- | -------- | ---------------------------------------------------------------------- |
| `note`          | string   | Yes      | The insight, decision, or knowledge to document (Markdown supported)   |
| `directoryPath` | string   | Yes      | Path where this knowledge applies                                      |
| `tags`          | string[] | Yes      | Semantic tags for categorization                                       |
| `anchors`       | string[] | No       | Additional file/directory paths or keywords to associate with the note |
| `confidence`    | string   | No       | Confidence level: 'high', 'medium', 'low'                              |
| `type`          | string   | No       | Note type: 'decision', 'pattern', 'gotcha', 'explanation'              |
| `metadata`      | object   | No       | Additional structured data                                             |

## Note Types

### Decision

Use for architectural decisions, technology choices, and important project decisions.

```json
{
  "type": "decision",
  "note": "Chose PostgreSQL over MongoDB for the primary database because our data has complex relationships and requires ACID compliance.",
  "tags": ["database", "architecture", "infrastructure"],
  "confidence": "high"
}
```

### Pattern

Use for reusable implementation patterns, coding conventions, and best practices.

```json
{
  "type": "pattern",
  "note": "All API calls should include error handling with user-friendly messages and fallback states.",
  "tags": ["error-handling", "api", "ux"],
  "anchors": ["/src/api", "/src/components/ErrorBoundary.tsx"]
}
```

### Gotcha

Use for common mistakes, edge cases, and pitfalls to avoid.

```json
{
  "type": "gotcha",
  "note": "Don't use async operations in useEffect without cleanup, as it can cause memory leaks when component unmounts.",
  "tags": ["react", "memory-leaks", "async"],
  "anchors": ["/src/hooks", "/src/components"]
}
```

### Explanation

Use for general documentation, setup instructions, and conceptual explanations.

```json
{
  "type": "explanation",
  "note": "The authentication flow works by storing JWT tokens in httpOnly cookies and using refresh tokens for session management.",
  "tags": ["authentication", "security", "jwt"]
}
```

## Best Practices

### Write Actionable Notes

```
❌ Bad: "We have a caching system"
✅ Good: "Use React Query for API caching with staleTime: 5 * 60 * 1000 for user data"
```

### Include Context

```
❌ Bad: "Use TypeScript"
✅ Good: "Use TypeScript strict mode for all new files to catch potential runtime errors early"
```

### Be Specific About Location

```
❌ Bad: "API error handling"
✅ Good: "API error handling in /src/api/client.ts - use handleApiError() function"
```

### Use Meaningful Tags

```
❌ Bad: ["code", "stuff"]
✅ Good: ["authentication", "security", "api", "error-handling"]
```

## Response Format

### Successful Creation

```json
{
  "success": true,
  "noteId": "note-1734567890123-abc123def",
  "message": "Note created successfully",
  "note": {
    "id": "note-1734567890123-abc123def",
    "content": "Your note content here...",
    "directoryPath": "/src/hooks",
    "tags": ["architecture", "state-management"],
    "anchors": ["/src/hooks/useUser.ts"],
    "confidence": "high",
    "type": "decision",
    "createdAt": "2024-01-15T10:30:00Z",
    "updatedAt": "2024-01-15T10:30:00Z"
  }
}
```

### Validation Error

```json
{
  "success": false,
  "error": "Validation failed",
  "details": {
    "note": "Note content cannot be empty",
    "tags": "At least one tag is required"
  }
}
```

## Examples

### Example 1: Architecture Decision

```json
{
  "note": "Adopted micro-frontend architecture to enable independent deployment of different business domains. Each micro-frontend owns its own routing, state, and build process.",
  "directoryPath": "/packages",
  "tags": ["architecture", "micro-frontends", "deployment"],
  "anchors": ["/packages/auth", "/packages/dashboard", "/packages/admin"],
  "confidence": "high",
  "type": "decision",
  "metadata": {
    "alternatives": ["Monolithic SPA", "Module federation"],
    "benefits": ["Independent deployment", "Technology diversity", "Team autonomy"],
    "challenges": ["Shared component management", "Cross-app communication"]
  }
}
```

### Example 2: Code Pattern

```json
{
  "note": "Use custom hooks for business logic separation. Always extract complex stateful logic from components into custom hooks following the pattern: use[Feature].ts",
  "directoryPath": "/src/hooks",
  "tags": ["patterns", "react", "custom-hooks"],
  "anchors": ["/src/hooks/useAuth.ts", "/src/hooks/useApi.ts"],
  "confidence": "high",
  "type": "pattern"
}
```

### Example 3: Gotcha Documentation

```json
{
  "note": "When using useEffect with async operations, always add a cleanup function to prevent state updates on unmounted components. Use the abort controller pattern for cancellable requests.",
  "directoryPath": "/src/components",
  "tags": ["react", "gotchas", "async", "memory-leaks"],
  "confidence": "high",
  "type": "gotcha",
  "metadata": {
    "common_error": "Cannot update state on unmounted component",
    "solution": "Add cleanup function to useEffect"
  }
}
```

## Integration with AI Agents

AI agents should proactively create notes when:

1. **Solving complex problems** - Document the solution approach
2. **Making architectural decisions** - Record why choices were made
3. **Discovering edge cases** - Note workarounds and fixes
4. **Learning new patterns** - Share knowledge with the team

## Related Tools

- **[askA24zMemory](/api/askA24zMemory)** - Query existing notes
- **[get_repository_tags](/api/get-repository-tags)** - Discover available tags
- **[find_similar_notes](/api/find-similar-notes)** - Find related information
