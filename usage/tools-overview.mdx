---
title: "Tools Overview"
description: "Overview of A24z Memory MCP tools and their capabilities"
---

# Introduction

A24z Memory provides several MCP tools to help AI agents interact with project knowledge. This guide explains each tool's purpose and when to use it.

## Core Tools

### askA24zMemory

**Purpose**: Query the knowledge base for contextual guidance and tribal knowledge.

**When to use**:
- Starting work on unfamiliar code or patterns
- Making architectural or implementation decisions
- Understanding project conventions
- Debugging complex issues
- Learning about past solutions

**Example workflow**:
1. AI agent encounters new component pattern
2. Queries A24z Memory: "What patterns exist for form validation in this project?"
3. Receives context about existing validation approaches
4. Applies consistent patterns to new code

### create_repository_note

**Purpose**: Store important insights, decisions, and knowledge for future reference.

**When to use**:
- After implementing significant features
- When making architectural decisions
- After solving complex problems
- When establishing new patterns or conventions
- When documenting important discoveries

**Note types**:
- **Decision**: Architecture choices, technology selections
- **Pattern**: Reusable implementation patterns
- **Gotcha**: Common mistakes and solutions
- **Explanation**: General documentation and guides

### get_repository_tags

**Purpose**: Discover available tags for categorizing notes and understand project taxonomy.

**When to use**:
- Before creating new notes (to use consistent tags)
- Understanding project technology stack
- Exploring what types of knowledge exist
- Planning note organization

### get_repository_guidance

**Purpose**: Get repository-specific configuration, standards, and documentation guidance.

**When to use**:
- New team member onboarding
- Understanding project standards
- Setting up consistent documentation practices
- Reviewing team conventions

## Advanced Tools

### get_repository_note

**Purpose**: Retrieve a specific note by its unique ID for detailed information.

**When to use**:
- Get detailed information about a specific note
- Review note content and metadata
- Check note anchors and related files
- Follow up on note references from other tools

**Example workflow**:
1. Get note ID from search results or other tools
2. Retrieve complete note details
3. Review content, metadata, and anchors
4. Use information for decision making or documentation

### check_stale_notes

**Purpose**: Check for notes with stale anchors (file paths that no longer exist).

**When to use**:
- Find notes that reference deleted or moved files
- Maintain note accuracy and relevance
- Clean up outdated documentation
- Regular knowledge base maintenance

**Example workflow**:
1. Run stale note check after file operations
2. Review notes with broken anchors
3. Update or remove outdated notes
4. Maintain knowledge base quality

### discover_a24z_tools

**Purpose**: Discover all available a24z-Memory tools and their capabilities.

**When to use**:
- Understand what tools are available
- Learn how to use tools effectively
- Get tool usage examples and parameters
- Explore new features as they're added

**Example workflow**:
1. New user wants to explore capabilities
2. AI agent uses discover tool to show available options
3. User selects appropriate tools for their needs
4. AI agent provides guidance on tool usage

### find_similar_notes

**Purpose**: Find notes with similar content to avoid duplication and discover related information.

**When to use**:
- Before creating new notes (check for existing content)
- Researching related topics
- Consolidating similar information
- Understanding how topics interconnect

### merge_notes

**Purpose**: Combine multiple related notes into comprehensive documentation.

**When to use**:
- Consolidating duplicate information
- Creating comprehensive guides from fragments
- Organizing scattered knowledge
- Improving information discoverability

### review_duplicates

**Purpose**: Analyze knowledge base for duplicate or highly similar notes.

**When to use**:
- Regular knowledge base maintenance
- Before major refactoring or reorganization
- Quality assurance of documentation
- Identifying consolidation opportunities

### delete_note

**Purpose**: Remove outdated or incorrect notes from the knowledge base.

**When to use**:
- Removing deprecated information
- Correcting factual errors
- Cleaning up after refactoring
- Removing redundant content

## Tool Usage Patterns

### Daily Development Workflow

1. **Start of session**: Query existing knowledge about current work area
2. **During implementation**: Check patterns and conventions as needed
3. **After completion**: Document insights and decisions
4. **End of session**: Review and organize created notes

### New Feature Development

1. **Planning phase**: Research existing patterns and decisions
2. **Implementation**: Follow established conventions
3. **Review**: Document architectural decisions
4. **Documentation**: Create notes about new patterns or approaches

### Code Review Process

1. **Pre-review**: Check for relevant patterns and standards
2. **During review**: Reference existing documentation
3. **Post-review**: Document new insights or decisions
4. **Follow-up**: Update patterns based on feedback

### Team Onboarding

1. **Initial setup**: Get repository guidance and standards
2. **Knowledge transfer**: Explore existing notes and patterns
3. **Hands-on learning**: Query specific topics as they arise
4. **Contribution**: Start creating notes about discoveries

## Best Practices

### Effective Queries

```
❌ Bad: "How do I code?"
✅ Good: "What's the project's approach to API error handling?"
```

```
❌ Bad: "Authentication"
✅ Good: "What authentication patterns are used in this React app?"
```

### Quality Notes

**Include context**: Explain why decisions were made, not just what was decided.

**Add examples**: Include code snippets, file paths, and concrete examples.

**Use appropriate tags**: Choose tags that reflect technology, purpose, and scope.

**Keep it actionable**: Focus on information that helps other developers.

### Knowledge Organization

**Consistent tagging**: Use the same tags for similar concepts across the project.

**Logical anchoring**: Attach notes to relevant files and directories.

**Regular maintenance**: Review and update notes as the project evolves.

**Quality over quantity**: Focus on high-value insights rather than exhaustive documentation.

## Integration Examples

### With Code Generation

```typescript
// AI Agent: I need to implement a user authentication hook
// First, query existing patterns
const existingPatterns = await askA24zMemory({
  filePath: "/src/hooks",
  query: "What authentication hook patterns exist in this project?"
});

// Apply the discovered patterns to new code
// Then create a note about the new implementation
```

### With Architecture Decisions

```typescript
// AI Agent: Considering whether to use Redux or Context API
const decisionHistory = await askA24zMemory({
  query: "What were the previous decisions about state management in this project?",
  taskContext: "Evaluating Redux vs Context API for new feature"
});

// Use historical context to inform current decision
// Document the new decision with reasoning
```

### With Code Review

```typescript
// AI Agent: Reviewing a complex component
const patterns = await askA24zMemory({
  filePath: "/src/components/UserProfile.tsx",
  query: "What patterns exist for complex component state management?"
});

// Apply patterns to improve the code
// Create notes about any new patterns discovered
```

## Troubleshooting

### Tool Not Available

If AI agent can't access tools:
- Verify MCP server is running
- Check system prompt configuration
- Restart the editor/IDE
- Confirm tool names match exactly

### No Relevant Information

When queries return no results:
- This is normal for new repositories
- Start by creating foundational notes
- Use broader queries to find general patterns
- Consider if the query is too specific

### Too Much Information

When queries return too many results:
- Use more specific file paths
- Add filter tags to narrow results
- Break complex queries into smaller parts
- Use taskContext to provide focus

## Performance Considerations

### Large Codebases

For repositories with extensive knowledge bases:
- Use specific file paths to narrow searches
- Leverage tag filtering for better results
- Consider periodic knowledge base cleanup
- Use find_similar_notes to consolidate related information

### Frequent Queries

To optimize performance:
- Cache frequently accessed information
- Use appropriate similarity thresholds
- Consider repository structure when organizing notes
- Regularly review and optimize the knowledge base

## Next Steps

<Card title="Try the quick start" icon="rocket" href="/quickstart">
  Get up and running with your first A24z Memory query.
</Card>

<Card title="Explore API reference" icon="code" href="/api/askA24zMemory">
  Learn detailed usage for each tool.
</Card>

<Card title="Configure repository guidance" icon="settings" href="/api/get-repository-guidance">
  Set up custom guidance and standards.
</Card>
